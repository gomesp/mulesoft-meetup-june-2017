## Why microservices?

* Microservices are an answer to the challenges with monoliths. <!-- .element: class="fragment fade-in" -->
* Monoliths can be difficult to deploy. So we don't deploy very often. <!-- .element: class="fragment fade-in" -->
* Massive regression testing cycle for each software iteration. <!-- .element: class="fragment fade-in" -->
* Security risk. Monoliths have a large attack surface. <!-- .element: class="fragment fade-in" -->
* If a part of the application has strict change control, then everything must be under strict change control. <!-- .element: class="fragment fade-in" -->
* Scalability must consider the entire compute requirements. <!-- .element: class="fragment fade-in" -->
* Time-to-market is slow. <!-- .element: class="fragment fade-in" -->

Note:
* Security: "Insecure applications hidden behind firewalls make you feel secure until the breach happens..."
* Change control: "Because one part of the monolithic application and database holds sensitive data, all of it is subject to the most rigorous policies..."

<hr>

## So, again, why microservices? 

### Microservices are built and managed at scale <!-- .element: class="fragment fade-in" -->

<hr>

### Compute resource utilisation is optimised to its requirements

<hr>

### Can be written in any language and use any data store. Optimised for the service requirements

<hr>

### Having its own datastore improves its independence and resiliency

<hr>

### Services are resilient and built to tolerate external failure

<hr>

### Time to market is fast. Built around small teams.

<hr>

## Risks and benefits

* TODO: What are the pros and cons of a microservices architecture

<hr>

## Is my organisation ready to adopt microservices?

1. Embrace the DevOps culture <!-- .element: class="fragment fade-in" -->
1. Rapid provisioning of compute resources <!-- .element: class="fragment fade-in" -->
1. Basic monitoring, where MTTR is more important than MTBF <!-- .element: class="fragment fade-in" -->
1. Rapid deployment <!-- .element: class="fragment fade-in" -->
1. Easy to provision storage <!-- .element: class="fragment fade-in" -->
1. Easy access to the edge <!-- .element: class="fragment fade-in" -->
1. Authentication/Authorisation <!-- .element: class="fragment fade-in" -->
1. Standardised RPC <!-- .element: class="fragment fade-in" -->


